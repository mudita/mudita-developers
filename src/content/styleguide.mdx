# General

## Prettier, Linter and other automatic tools

Most convention you'll find in this guide requires some manual, intentional effort from programmer. Thankfully all other
stuff that's not included is hidden in automatic tools configuration. Most of those configs are the tools' defaults
with some notable exceptions you'll find reading this guide.

# Files and modules organisation

## Files naming convention

When naming files, you need to remember about few things.
- Use the kebab case convention so the filename will look like it's a part of the URL. We're web devs after all.
- Usually add a file type suffix informing what type of file it is (e.g `.component`). That way it'll be easier to find
  the file you need.
- Name the file the same as the main (default) export.

The available file type suffixes (list is non-exhaustive):
- `.component` for React components,
- `.stories` for files holding Storybook stories,
- `.test` for unit tests,
- `.e2e` for end-to-end tests,
- `.fragment` for GraphQL fragments,
- `.interface` for interfaces,
- `.request` for modules exposing an HTTP request.

There are some modules that doesn't need that suffix. It usually happen when the filename is important (like in the
`/pages` folder in Gatsby projects) or the exported value is a function (then `.function` suffix would be redundant, as
the module name alone would inform it's a function, eg. `get-some-data.ts`).

### Examples

```ts
contact-form.component.tsx
contact-form-component.stories.tsx
contact-form-component.test.tsx
contact-form-component.e2e.tsx
user-profile.fragment.ts
user-profile.interface.ts
get-user-profile.request.ts
parse-user-profile.ts
```

## Folders structure and files organisation

Keep the related files in one catalogue for ease of finding the relation and working on a single module.

### Examples

```typescript
├── button
│   ├── button.component.tsx
│   ├── button-component.test.tsx
│   ├── button-component.stories.tsx
│   └── button-content.interface.ts
```

## Avoid index files

Do not create `index` files that reexport values from files inside a catalogue. They add unnecessary work that needs to
be done and checked for correctness, as well as it needs to be kept in sync in case new exports will show up.

# Style

- 80 columns
- no semicolons
- double quotes,
- two spaces,
- ...

# Code

## Creating components

Prefer function components over class components for the smaller code-print. Use the `AppFunctionComponent` interface
to type the component. Declare it as a constant and then export that constant as a default export of the module. Keep
only a single component in a file (with an exception of styled components that makes up the main component).

### Example

```typescript
const MyComponent: AppFunctionComponent<Props> = () => {
  return <div />
}

export default MyComponent
```

## Component's properties

Declare the component's properties as the `Props` interface and use it in the AppFunctionComponent generic type.
Destructure the properties in the parameters declaration and provide default values for optional properties there
(if it makes sense for a prop to have a default).

### Example

```typescript
interface Props {
  property: string
  optionalProperty?: number
}

const MyComponent: AppFunctionComponent<Props> = ({ property, optionalProperty = 42 }) => {
  return (
    <div>
      {property}: {optionalProperty}
    </div>
  )
}
```

## Don't use arrow return

Prefer braces in the component, rather than arrow return to avoid potentially massive and unrelated diffs when
component will require more stuff in the body later in the game.

### Example

```typescript
// Good.
const MyComponent: AppFunctionComponent = () => {
  return <div />
}

// Bad. Will create a big diff when changed.
const MyComponent: AppFunctionComponent = () => <div />
```

## Hooks

## AppFunctionComponent and its extensions

`AppFunctionComponent` interface is a basic component type in all of our applications. On top of extending the React's
`FunctionComponent` it provides two additional benefits:

- it makes all the properties on the root lever `readonly` to prevent their accidental modification,
- it adds `className: string` property so that all components will be easily stylable.

When the app have some other specific properties that all components can use, then extend the `AppFunctionComponent`
rather than creating a new name variant to avoid confusion for developers working on other apps.

```typescript
// Base AppFunctionComponent
interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string }>> {}

// Extended interface
interface IntlProps {
  intl: (label: string) => string
}

interface AppFunctionComponent<P = {}>
  extends FunctionComponent<Readonly<P & { className?: string } & IntlProps>> {}
```

## Styling components

Don't export styled components unnecessarily.

If you need them in multiple files, then maybe you need a separate file for that component.


```typescript
const HeaderRoot = styled.header`
  background: red
`

const Header: AppFunctionComponent = () => {
  return (
    <HeaderRoot>App'n'roll</HeaderRoot>
  )
}

export default Header
```

## Smart adn dumb

contact-form & contact-form-ui

## Treat imports in a module as a blackbox

Don't manually manage them. Don't group them. Allow IDE, linters and other tools to take care fo that.

## Avoid `any`

But not at any cost. Try to figure out the expected type of a value and type it properly so that you and your fellow
programmers will get the benefit of type safety and IDE support.

In rare cases, when type is difficult to use, you can use an explicit `any`. But keep in mind you might get a change
request in code review if the type was not that complex.

# Tests

## Test filenames convention

For unit tests use the `.test.ts(x)` suffix and for end-to-end tests use `.e2e.ts(x)`. That way they'll be easy
to find in the component's catalogue.

### Examples

```typescript
button.test.tsx
checkout.e2e.tsx
```

## writing tests

on root, test("x works"), no "should"

## Use `test`

When declaring a test use the `test` function (instead of `it`). It nicely feet into tests (it's a `test` after all).

### Examples

```typescript
// Good.
test("writes good tests", () => ...)

// Bad. (Well, not really, but still…)
it("doesn't write good tests", () => ...)
```

## You should not `should`

Keep tests simple. "Works" is enough. We know it should.

### Examples

```typescript
// Good.
test("works when clicked", () => ...)

// Bad.
test("should work when clicked", () => ...)
```

## Expose custom getters in the renderer when necessary

### Examples

```typescript
const renderMyComponent = () => {
  const outcome = render(<MyComponent />)
  return {
    ...outcome,
    getButton: () => outcome.getByRole("button")
  }
}

test("clicking a button does something", () => {
  const { getButton } = renderMyComponent()
  // ...
})
```

## Use arrow function as a callback

Use only arrow functions in the test's callback. Don't use function expression or a reference.

### Examples

```typescript
// Good.
test("with good callback", () => ...)

// Bad.
test("with bad callback", function() { ... })
```

## Don't use root level `describe`

The module's name is enough to find a test and know what it is.

### Examples

```typescript
// Bad.
describe("MyComponent test", () => {
  test("", () => ...)
})

// Good. (Just test.)
test("", () => ...)
```

# Stories
